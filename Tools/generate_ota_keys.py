#!/usr/bin/env python3
"""
OTA Key Generator for SRT-MGATE-1210
Generates ECDSA P-256 key pair for firmware signing

Usage:
    python generate_ota_keys.py

Output:
    - ota_private_key.pem  (KEEP SECRET!)
    - ota_public_key.pem
    - ota_public_key.h     (C header for firmware)

Requirements:
    pip install ecdsa
"""

import os
import sys

try:
    from ecdsa import SigningKey, VerifyingKey, NIST256p
    from ecdsa.util import sigencode_der, sigdecode_der
except ImportError:
    print("Error: ecdsa module not found")
    print("Install with: pip install ecdsa")
    sys.exit(1)


def generate_keys(output_dir="."):
    """Generate ECDSA P-256 key pair"""

    print("=" * 60)
    print("OTA Key Generator for SRT-MGATE-1210")
    print("=" * 60)

    # Generate private key
    print("\n[1/4] Generating ECDSA P-256 private key...")
    private_key = SigningKey.generate(curve=NIST256p)

    # Extract public key
    public_key = private_key.get_verifying_key()

    # Save private key (PEM format)
    private_key_path = os.path.join(output_dir, "ota_private_key.pem")
    print(f"[2/4] Saving private key: {private_key_path}")
    with open(private_key_path, "wb") as f:
        f.write(private_key.to_pem())

    # Save public key (PEM format)
    public_key_path = os.path.join(output_dir, "ota_public_key.pem")
    print(f"[3/4] Saving public key: {public_key_path}")
    with open(public_key_path, "wb") as f:
        f.write(public_key.to_pem())

    # Generate C header file
    header_path = os.path.join(output_dir, "ota_public_key.h")
    print(f"[4/4] Generating C header: {header_path}")

    # Get raw public key bytes (uncompressed format: 04 + X + Y)
    raw_pubkey = b"\x04" + public_key.to_string()

    # Generate C array
    c_array = generate_c_array(raw_pubkey)

    with open(header_path, "w") as f:
        f.write(generate_header_file(c_array, raw_pubkey))

    print("\n" + "=" * 60)
    print("KEY GENERATION COMPLETE!")
    print("=" * 60)

    print(
        f"""
Files created:
  1. {private_key_path}  <- KEEP THIS SECRET!
  2. {public_key_path}
  3. {header_path}        <- Copy to firmware

IMPORTANT:
  - NEVER share or commit ota_private_key.pem to Git!
  - Add to .gitignore: ota_private_key.pem
  - Backup private key securely offline

Next steps:
  1. Copy the content from {header_path}
  2. Paste into Main/OTAConfig.h (replace OTA_PUBLIC_KEY array)
  3. Compile and flash firmware
  4. Use sign_firmware.py to sign new firmware releases
"""
    )

    # Print public key for verification
    print("\nPublic Key (hex):")
    print(raw_pubkey.hex())

    return private_key_path, public_key_path, header_path


def generate_c_array(data):
    """Convert bytes to C array string"""
    lines = []
    for i in range(0, len(data), 8):
        chunk = data[i : i + 8]
        hex_values = ", ".join(f"0x{b:02X}" for b in chunk)
        lines.append(f"    {hex_values}")
    return ",\n".join(lines)


def generate_header_file(c_array, raw_pubkey):
    """Generate C header file content"""
    return f"""/**
 * @file ota_public_key.h
 * @brief ECDSA P-256 Public Key for OTA Signature Verification
 * @generated by generate_ota_keys.py
 *
 * INSTRUCTIONS:
 * Copy the OTA_PUBLIC_KEY array below and paste it into
 * Main/OTAConfig.h to replace the existing public key.
 */

#ifndef OTA_PUBLIC_KEY_H
#define OTA_PUBLIC_KEY_H

/**
 * ECDSA P-256 Public Key (65 bytes, uncompressed format)
 * Format: 0x04 (uncompressed indicator) + X (32 bytes) + Y (32 bytes)
 *
 * Key fingerprint: {raw_pubkey[:8].hex()}...
 */
static const uint8_t OTA_PUBLIC_KEY[] = {{
{c_array}
}};

static const size_t OTA_PUBLIC_KEY_SIZE = sizeof(OTA_PUBLIC_KEY);

#endif // OTA_PUBLIC_KEY_H
"""


if __name__ == "__main__":
    # Default output directory is OTA_Keys (relative to script location)
    script_dir = os.path.dirname(os.path.abspath(__file__))
    default_output = os.path.join(script_dir, "OTA_Keys")

    if len(sys.argv) > 1:
        output_dir = sys.argv[1]
    else:
        output_dir = default_output

    if not os.path.exists(output_dir):
        os.makedirs(output_dir)

    generate_keys(output_dir)
